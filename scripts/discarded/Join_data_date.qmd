---
title: "Joining the lab test data"
author: "Asbjørn kloppenborg (askl@ph.au.dk)"
format: html
---

---
title: "Join APS & SMPS (Mass + Number) via Full Join"
format:
  html:
    toc: true
    code-fold: show
execute:
  echo: true
  warning: true
  message: true

params:
  # ==== MASS FILES (required for mass join) ====
  smps_mass_rda: "SMPS_mass_20250521.rda"
  aps_mass_rda:  "APS_mass_20250521.rda"

  # ==== NUMBER FILES (optional; fill to run number join) ====
  smps_number_rda: null    # e.g. "SMPS_number_20250521.rda"
  aps_number_rda:  null    # e.g. "APS_number_20250521.rda"

  # ==== JOIN / TIME SETTINGS ====
  # Timezone used for parsing/printing timestamps (adjust to your lab TZ)
  tz: "UTC"

  # Optionally round timestamps before joining (keeps full join).
  # Examples: null | "10 sec" | "30 sec" | "1 min"
  round_to: null

  # Where to write joined outputs (CSV + RDS)
  out_dir: "clean_data/joined"
---

```{r}
#| label: setup
library(dplyr)
library(readr)
library(stringr)
library(lubridate)
library(tidyr)
library(purrr)

# Make sure output dir exists
dir.create(params$out_dir, recursive = TRUE, showWarnings = FALSE)

```

```{r}
#| label: helpers

# Load a single .rda and return the first data.frame/tibble inside.
load_first_table <- function(path) {
  stopifnot(file.exists(path))
  env <- new.env(parent = emptyenv())
  loaded <- load(path, envir = env)
  if (length(loaded) == 0) {
    stop("No objects found in ", path)
  }
  # pick the first data.frame/tibble if multiple objects exist
  objs <- mget(loaded, envir = env)
  tbl_name <- names(objs)[map_lgl(objs, ~ inherits(.x, c("data.frame", "tbl_df")) )][1]
  if (is.na(tbl_name)) {
    stop("No data.frame/tibble found in ", path,
         ". Found: ", paste(loaded, collapse = ", "))
  }
  df <- objs[[tbl_name]]
  df
}

# Find a timestamp column and coerce to POSIXct in the requested tz
# Supports common names; otherwise keeps POSIXct if already present.
coerce_timestamp <- function(df, tz = "UTC") {
  candidate_names <- c("timestamp", "time", "date_time", "datetime", "date.time", "DateTime")
  cand <- intersect(candidate_names, names(df))
  if (length(cand) == 0) {
    stop("No timestamp-like column found. Looked for: ",
         paste(candidate_names, collapse = ", "))
  }
  ts_col <- cand[1]

  # If character, try ymd_hms/dmy_hms/mdy_hms heuristics
  x <- df[[ts_col]]
  if (inherits(x, "POSIXct")) {
    ts <- with_tz(x, tz = tz)
  } else if (is.character(x)) {
    # Try multiple parsers; keep first that works
    parsers <- list(ymd_hms, dmy_hms, mdy_hms, ymd_hm, dmy_hm, mdy_hm)
    ts <- NULL
    for (p in parsers) {
      ts_try <- suppressWarnings(p(x, tz = tz))
      if (sum(!is.na(ts_try)) >= sum(!is.na(x)) * 0.7) { # be pragmatic
        ts <- ts_try
        break
      }
    }
    if (is.null(ts)) {
      stop("Could not parse timestamp column: ", ts_col)
    }
  } else if (is.numeric(x)) {
    # If numeric, assume seconds from a start—leave as is; user may adjust later
    ts <- as_datetime(x, tz = tz)
  } else {
    stop("Unsupported timestamp type in column ", ts_col, ". Class: ", class(x)[1])
  }

  df |>
    mutate(timestamp = ts) |>
    arrange(timestamp)
}

# Optionally round timestamps to a grid (still full-joined afterwards)
maybe_round_time <- function(df, round_to = NULL) {
  if (is.null(round_to) || is.na(round_to) || !nzchar(round_to)) {
    return(df)
  }
  # Convert "10 sec", "1 min" to period and floor
  unit <- str_extract(round_to, "(sec|secs|second|seconds|min|mins|minute|minutes|hour|hours)")
  n    <- suppressWarnings(as.integer(str_extract(round_to, "\\d+")))
  if (is.na(n) || is.na(unit)) {
    stop("round_to must look like '10 sec', '30 sec', '1 min', '5 min', etc.")
  }
  period <-
    if (str_starts(unit, "sec")) seconds(n)
    else if (str_starts(unit, "min")) minutes(n)
    else if (str_starts(unit, "hour")) hours(n)
    else stop("Unsupported unit in round_to: ", unit)

  df |>
    mutate(timestamp = lubridate::floor_date(timestamp, unit = period))
}

# Pick first matching column name among synonyms; optionally rename it
pick_cols <- function(df, mapping) {
  # mapping: named list: new_name = c("candidate1","candidate2",...)
  out <- list()
  for (nm in names(mapping)) {
    cand <- intersect(mapping[[nm]], names(df))
    out[[nm]] <- if (length(cand)) cand[1] else NA_character_
  }
  found <- discard(out, is.na)
  if (length(found) == 0L) {
    tibble()
  } else {
    df |> select(all_of(unname(found))) |> rlang::set_names(names(found))
  }
}

# Minimal mass selection/standardization
standardize_mass <- function(df, instrument) {
  # Common mass names from your scripts
  pm_map <- list(
    timestamp   = "timestamp",
    PM1_ug_m3   = c("PM1_ug_m3", "PM1", "pm1", "pm1_ug_m3"),
    PM2.5_ug_m3 = c("PM2.5_ug_m3", "PM2_5_ug_m3", "PM2.5", "pm2.5", "pm25")
  )
  sel <- pick_cols(df, pm_map)
  if (!"timestamp" %in% names(sel)) {
    sel <- bind_cols(tibble(timestamp = df$timestamp), sel)
  }
  sel |> mutate(instrument = instrument)
}

# Minimal number selection/standardization
standardize_number <- function(df, instrument) {
  pn_map <- list(
    timestamp = "timestamp",
    PN0.5     = c("PN0.5", "PN0_5", "pn0.5", "pn0_5"),
    PN1       = c("PN1", "pn1"),
    PN2.5     = c("PN2.5", "PN2_5", "pn2.5", "pn2_5")
  )
  sel <- pick_cols(df, pn_map)
  if (!"timestamp" %in% names(sel)) {
    sel <- bind_cols(tibble(timestamp = df$timestamp), sel)
  }
  sel |> mutate(instrument = instrument)
}

```
